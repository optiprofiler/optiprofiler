function writeReport(profile_options, results_plibs, path_report, path_readme_log)
%WRITEREPORT writes the report of the current experiment to a file.

    if profile_options.(ProfileOptionKey.SCORE_ONLY.value)
        % If the score-only option is set, do not write the report file.
        return;
    end

    try
        fid = fopen(path_report, 'w');
        fprintf(fid, "# Report file for the current experiment\n\n");
        fprintf(fid, "This report file is generated by OptiProfiler <www.optprof.com>\n\n");
        fprintf(fid, "## Summary of the experiment\n\n");
        solver_names = results_plibs{1}.solver_names;
        fprintf(fid, "Solver names:            %s\n", strjoin(solver_names, ', '));
        fprintf(fid, "Problem types:           %s\n", results_plibs{1}.ptype);
        fprintf(fid, "Problem mindim:          %d\n", results_plibs{1}.mindim);
        fprintf(fid, "Problem maxdim:          %d\n", results_plibs{1}.maxdim);
        if any(ismember(results_plibs{1}.ptype, 'bln'))
        fprintf(fid, "Problem minb:            %d\n", results_plibs{1}.minb);
        fprintf(fid, "Problem maxb:            %d\n", results_plibs{1}.maxb);
        end
        if any(ismember(results_plibs{1}.ptype, 'ln'))
        fprintf(fid, "Problem minlcon:         %d\n", results_plibs{1}.minlcon);
        fprintf(fid, "Problem maxlcon:         %d\n", results_plibs{1}.maxlcon);
        end
        if any(ismember(results_plibs{1}.ptype, 'n'))
        fprintf(fid, "Problem minnlcon:        %d\n", results_plibs{1}.minnlcon);
        fprintf(fid, "Problem maxnlcon:        %d\n", results_plibs{1}.maxnlcon);
        end
        if any(ismember(results_plibs{1}.ptype, 'ln'))
        fprintf(fid, "Problem mincon:          %d\n", results_plibs{1}.mincon);
        fprintf(fid, "Problem maxcon:          %d\n", results_plibs{1}.maxcon);
        end
        if ~isempty(results_plibs{1}.problem_names_options)
        fprintf(fid, "Problem names from user: %s\n", strjoin(results_plibs{1}.problem_names_options, ', '));
        else
        fprintf(fid, "Problem names from user: This part is empty.\n");
        end
        if ~isempty(results_plibs{1}.excludelist)
        fprintf(fid, "Exclude list from user:  %s\n", strjoin(results_plibs{1}.excludelist, ', '));
        else
        fprintf(fid, "Exclude list from user:  This part is empty.\n");
        end
        fprintf(fid, "Feature stamp:           %s\n", results_plibs{1}.feature_stamp);
        fprintf(fid, '\n');

        for i_plib = 1:size(results_plibs, 2)
            results_plib = results_plibs{i_plib};
            plib = results_plib.plib;
            problem_names = results_plib.problem_names;
            problem_types = results_plib.problem_types;
            problem_dims = results_plib.problem_dims;
            problem_mbs = results_plib.problem_mbs;
            problem_mlcons = results_plib.problem_mlcons;
            problem_mnlcons = results_plib.problem_mnlcons;
            problem_mcons = results_plib.problem_mcons;
            solvers_successes = results_plib.solvers_successes;
            computation_times = results_plib.computation_times;
            if isfield(results_plibs{i_plib}, 'results_plib_plain') && profile_options.(ProfileOptionKey.RUN_PLAIN.value)
                results_plib_plain = results_plibs{i_plib}.results_plib_plain;
                problem_names_plain = results_plib_plain.problem_names;
                computation_times_plain = results_plib_plain.computation_times;
                computation_times = cat(3, results_plib.computation_times, NaN(size(computation_times_plain)));
                for i_problem = 1:numel(problem_names)
                    idx = find(strcmp(problem_names{i_problem}, problem_names_plain), 1);
                    computation_times(i_problem, :, size(computation_times, 3)) = computation_times_plain(idx, :, :);
                end
            end

            % Pick out unsolved problems and calculate the computation times for each problem.
            unsolved_problems = [];
            time_processes = zeros(numel(problem_names), 1);
            for i_problem = 1:numel(problem_names)
                if all(~solvers_successes(i_problem, :, :))
                    unsolved_problems = [unsolved_problems, problem_names(i_problem)];
                end
                time_process = computation_times(i_problem, :, :);
                time_processes(i_problem) = sum(time_process(:), 'omitnan');
            end
            [~, idx] = sort(lower(problem_names));
            sorted_problem_names = problem_names(idx);
            sorted_problem_types = problem_types(idx);
            sorted_problem_dims = num2cell(problem_dims(idx));
            sorted_problem_mbs = num2cell(problem_mbs(idx));
            sorted_problem_mlcons = num2cell(problem_mlcons(idx));
            sorted_problem_mnlcons = num2cell(problem_mnlcons(idx));
            sorted_problem_mcons = num2cell(problem_mcons(idx));
            sorted_time_processes = num2cell(time_processes(idx));
            max_name_length = max(max(cellfun(@length, sorted_problem_names)), 12);
            max_type_length = max(max(cellfun(@length, sorted_problem_types)), 4);
            max_dim_length = max(max(cellfun(@length, sorted_problem_dims)), 9);
            max_mbs_length = max(max(cellfun(@length, sorted_problem_mbs)), 2);
            max_mlcons_length = max(max(cellfun(@length, sorted_problem_mlcons)), 5);
            max_mnlcons_length = max(max(cellfun(@length, sorted_problem_mnlcons)), 6);
            max_mcons_length = max(max(cellfun(@length, sorted_problem_mcons)), 4);
            max_time_length = max(max(cellfun(@(x) length(sprintf('%.2f', x)), sorted_time_processes)), 28);

            % Print the report file.
            fprintf(fid, '## Report for the problem library "%s"\n\n', plib);
            fprintf(fid, 'Number of problems selected: %d\n', length(sorted_problem_names));
            fprintf(fid, 'Wall-clock time spent by all the solvers: %.2f secs\n\n', sum(time_processes, 'omitnan'));

            if length(unsolved_problems) < length(sorted_problem_names)
                fprintf(fid, "%-*s    %-*s    %-*s    %-*s    %-*s    %-*s    %-*s    %-*s\n", max_name_length, "Problem name", max_type_length, "Type", max_dim_length, "Dimension", max_mbs_length, "mb", max_mlcons_length, "mlcon", max_mnlcons_length, "mnlcon", max_mcons_length, "mcon", max_time_length, "Time spent by solvers (secs)");
                for i = 1:length(sorted_problem_names)
                    if ismember(sorted_problem_names{i}, unsolved_problems)
                        continue;
                    end
                    name = sorted_problem_names{i};
                    type = sorted_problem_types{i};
                    dim = sprintf('%d', sorted_problem_dims{i});
                    mb = sprintf('%d', sorted_problem_mbs{i});
                    mlcon = sprintf('%d', sorted_problem_mlcons{i});
                    mnlcon = sprintf('%d', sorted_problem_mnlcons{i});
                    mcon = sprintf('%d', sorted_problem_mcons{i});
                    time = sprintf('%.2f', sorted_time_processes{i});
                    count = fprintf(fid, "%-*s    %-*s    %-*s    %-*s    %-*s    %-*s    %-*s    %-*s\n", max_name_length, name, max_type_length, type, max_dim_length, dim, max_mbs_length, mb, max_mlcons_length, mlcon, max_mnlcons_length, mnlcon, max_mcons_length, mcon, max_time_length, time);
                    if count < 0
                        if ~profile_options.(ProfileOptionKey.SILENT.value)
                            fprintf("INFO: Failed to record data for %s.", sorted_problem_names{i});
                        end
                    end
                end
            else
                fprintf(fid, "This part is empty.\n");
            end
            fprintf(fid, '\n## Problems from the problem library "%s" that all the solvers failed to evaluate a single point\n\n', plib);
            if ~isempty(unsolved_problems)
                for i = 1:length(unsolved_problems)
                    count = fprintf(fid, "%s ", unsolved_problems{i});
                    if count < 0
                        if ~profile_options.(ProfileOptionKey.SILENT.value)
                            fprintf("INFO: Failed to record data for %s.", unsolved_problems{i});
                        end
                    end
                end
            else
                fprintf(fid, "This part is empty.\n");
            end
        end
        fclose(fid);
        addToReadme(path_readme_log, 'report.txt', 'File, the report file of the current experiment, recording information like problem names and time spent on solving each problem for all the problem libraries.');
    catch
        if ~profile_options.(ProfileOptionKey.SILENT.value)
            fprintf("INFO: Error occurred when writing the report to %s.\n", path_report);
        end
    end
end